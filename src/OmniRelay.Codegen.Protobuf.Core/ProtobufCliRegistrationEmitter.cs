using System.Text;
using Google.Protobuf.Reflection;

namespace OmniRelay.Codegen.Protobuf.Core;

/// <summary>
/// Emits a CLI-specific registration partial that connects generated message serializers
/// to the OmniRelay.Cli.Core ProtobufPayloadRegistry (AOT-friendly, no reflection).
/// </summary>
public static class ProtobufCliRegistrationEmitter
{
    public sealed record EmittedRegistration(string HintName, string Source);

    public static EmittedRegistration Emit(FileDescriptorSet descriptorSet, string descriptorPath)
    {
        var typeLookup = BuildTypeLookup(descriptorSet);
        var ns = "OmniRelay.Cli.Core";
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.Append("namespace ")
          .Append(ns)
          .AppendLine(";");
        sb.AppendLine();
        sb.AppendLine("public static partial class ProtobufPayloadRegistration");
        sb.AppendLine("{");
        sb.AppendLine("    static partial void RegisterAll(ProtobufPayloadRegistry registry)");
        sb.AppendLine("    {");
        foreach (var (protoName, typeInfo) in typeLookup)
        {
            var serializerType = $"global::{typeInfo.Namespace}.{typeInfo.CsharpName}OmniRelaySerializer";
            sb.Append("        registry.Register(\"")
              .Append(protoName)
              .Append("\", static json => ")
              .Append(serializerType)
              .AppendLine(".Serialize(json));");
        }
        sb.AppendLine("    }");
        sb.AppendLine("}");

        var hint = CreateHint(descriptorPath);
        return new EmittedRegistration(hint, sb.ToString());
    }

    private static Dictionary<string, TypeInfo> BuildTypeLookup(FileDescriptorSet descriptorSet)
    {
        var lookup = new Dictionary<string, TypeInfo>(StringComparer.Ordinal);

        foreach (var file in descriptorSet.File)
        {
            if (file.Service.Count == 0)
            {
                continue;
            }

            var csharpNamespace = ResolveNamespace(file);
            var prefix = string.IsNullOrWhiteSpace(file.Package) ? string.Empty : file.Package;
            foreach (var message in file.MessageType)
            {
                CollectMessageTypes(message, prefix, null, csharpNamespace, lookup);
            }
        }

        return lookup;
    }

    private static void CollectMessageTypes(DescriptorProto message, string? protoPrefix, string? csharpPrefix, string csharpNamespace, IDictionary<string, TypeInfo> map)
    {
        var protoName = string.IsNullOrEmpty(protoPrefix)
            ? message.Name
            : string.Concat(protoPrefix, ".", message.Name);

        var csharpName = string.IsNullOrEmpty(csharpPrefix)
            ? message.Name
            : string.Concat(csharpPrefix, ".Types.", message.Name);

        map[protoName] = new TypeInfo(csharpNamespace, csharpName);

        foreach (var nested in message.NestedType)
        {
            CollectMessageTypes(nested, protoName, csharpName, csharpNamespace, map);
        }
    }

    private static string ResolveNamespace(FileDescriptorProto file)
    {
        var optionNamespace = file.Options?.CsharpNamespace;
        if (!string.IsNullOrWhiteSpace(optionNamespace))
        {
            return optionNamespace!;
        }

        if (string.IsNullOrWhiteSpace(file.Package))
        {
            return "Protobuf";
        }

        var segments = file.Package.Split('.', StringSplitOptions.RemoveEmptyEntries)
            .Select(SanitizeIdentifier)
            .Select(ToPascalCase);
        return string.Join('.', segments);
    }

    private static string SanitizeIdentifier(string value)
    {
        var builder = new StringBuilder(value.Length);
        foreach (var ch in value)
        {
            builder.Append(char.IsLetterOrDigit(ch) ? ch : '_');
        }

        return builder.ToString();
    }

    private static string ToPascalCase(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return value;
        }

        var parts = value.Split('_', StringSplitOptions.RemoveEmptyEntries);
        var builder = new StringBuilder();
        foreach (var part in parts)
        {
            if (part.Length == 0)
            {
                continue;
            }

            builder.Append(char.ToUpperInvariant(part[0]));
            if (part.Length > 1)
            {
                builder.Append(part[1..].ToLowerInvariant());
            }
        }

        return builder.ToString();
    }

    private sealed record TypeInfo(string Namespace, string CsharpName)
    {
        public string Namespace { get; init; } = Namespace;
        public string CsharpName { get; init; } = CsharpName;
    }

    private static string CreateHint(string descriptorPath)
    {
        var descriptorName = Path.GetFileNameWithoutExtension(descriptorPath);
        return $"{descriptorName}_ProtobufCliRegistration.g.cs";
    }
}
